<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  </head>
  <body id="body">
    <div class="body-content">
        <div class="header">header</div>
        <div class="middle">
            <div class="menu">
                menu<br><br><br>
                <a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">阮一峰 Flex 布局教程：语法篇</a><br>
                <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_flexible_box_layout/Controlling_ratios_of_flex_items_along_the_main_axis">MDN Flex 教程</a><br>
                <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements">MDN CSS 教程</a><br>
            </div>
            <div class="list">
                <div>item1</div><div>item2</div>
                <div>item3 Three<br>has<br>extra<br>text<br>has<br>extra<br>text</div>
                <div>class="item4"item45555555ggdfghfghgfnhfgnfgng<br>text</div>
            </div>
        </div>
        <div class="footer">
            <article>
                <p class="first">
                Veggies es bonus vobis, proinde vos postulo essum magis kohlrabi welsh onion daikon amaranth tatsoi tomatillo
                          melon azuki bean garlic.</p>
                <p>Gumbo beet greens corn soko endive gumbo gourd. Parsley shallot courgette tatsoi pea sprouts fava bean collard
                          greens dandelion okra wakame tomato. Dandelion cucumber earthnut pea peanut soko zucchini.</p>
              </article>
        </div>
    </div>
  </body>
</html>

<style type="text/css">
#body {
    margin: 0;
}
.header {
    height: 200px;
    background-color: aqua;
}
.middle {
    display: flex;
    flex-direction: row;
}
.menu {
    width: 300px;
    height: 200px;
    background-color: green;
}
.list {
    display: flex;
    /* 主轴方向 
    row | row-reverse | column | column-reverse 
    */
    flex-direction: row;
    /* 默认情况下，项目都排在一条线上。如果一条轴线排不下，如何换行 
    nowrap | wrap | wrap-reverse 
    */
    flex-wrap: wrap;
    /* 主轴上的对齐方式 
    flex-start | flex-end | center | space-between（两端对齐，项目之间的间隔都相等） | space-around（每个项目两侧的间隔相等） 
    */
    /* justify-content: space-between; */
    /* 交叉轴上如何对齐 
    flex-start | flex-end | center | baseline（项目的第一行文字的基线对齐） | stretch（默认值：如果项目未设置高度或设为auto，将占满整个容器的高度） 
    */
    align-items: center;
    /* 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
    flex-start | flex-end | center | space-between | space-around | stretch
    */
    align-content: flex-start;
    /* flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto
    该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。
    1. flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
    如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。
    如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。
    2. flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。负值对该属性无效。
    如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。
    如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
    3. flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。
    它的默认值为auto，即项目的本来大小。
    它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。
    空间分配时，如果你想要弹性盒子完全忽略元素的尺寸就需要设置 flex-basis 为 0。这显式地说明弹性盒子可用抢占所有空间，并按比例进行分配。
    */
    /* 剩余空间撑满，区块按子元素的flex-grow分配。详解看上面链接 */
    flex: 1 1 0;
}
.list :nth-child(1) {
    /* 剩余空间占一份 */
    flex: 1 1 0;
    background-color: bisque;
}
.list :nth-child(2) {
    /* 剩余空间占两份 */
    flex: 2 1 0;
    /* align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 */
    align-self: flex-end;
}
.list :nth-child(3) {
    /* 剩余空间占一份 */
    flex: 1 1 0;
    background-color: rebeccapurple;
}
.list :nth-child(4) {
    flex: 1 1 0;
}
.list > * {
    background-color: olive;
}
.footer {
    display: flex;
    flex-direction: row;
    height: 200px;
    background-color: yellow;
}
/*
类型选择器
strong {
  color: rebeccapurple;
}
全局选择器
* {
  margin: 0;
}
类选择器
.highlight {
  background-color: yellow;
}
id_选择器
#one {
  background-color: yellow;
}
*/
li[class] {/* 匹配带有一个名为attr的属性的元素——方括号里的值 */
  font-size: 200%;
}
li[class="a"] { /* 匹配带有一个名为attr的属性的元素，其值正为value——引号中的字符串 */
  background-color: yellow;
}
li[class~="a"] {/* 匹配带有一个名为attr的属性的元素，其值正为value，或者匹配带有一个attr属性的元素，其值有一个或者更多，至少有一个和value匹配 */
  color: red;
}
li[class^="a"] {/* 匹配了任何值开头为a的属性 */
  font-size: 200%;
}
li[class$="a"] {/* 匹配了任何值结尾为a的属性 */
  background-color: yellow;
}
li[class*="a"] {/* 匹配了任何值的字符串中出现了a的属性 */
  color: red;
}
/*
伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。
伪类就是开头为冒号的关键字： :pseudo-class-name 常见的 :first :focus :hover :last-child :nth-child :nth-of-type等
*/
/*
如果我们想要让一篇文章中的第一段变大加粗
1. 可以这样
2. 也可以用伪类，明显伪类更合适
*/
.first {
  font-size: 120%;
  font-weight: bold;
}
article p:first-child {
  font-size: 120%;
  font-weight: bold;
}
/*
伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。
伪元素开头为双冒号:: ::pseudo-element-name 常见的 ::first-letter ::first-line ::selection等
*/
.footer::before {
  content: "before";
  width: 60px;
  height: 60px;
  background-color: rebeccapurple;
  border: 2px solid gray;
}
.footer::after {
    /* 伪元素的更推荐的用法是插入一个图标 */
    content: " ➥";
}
/*
关系选择器
后代选择器：用单个空格（" "）字符——组合两个选择器 body article p
子代关系选择器：是个大于号（>），只会在选择器选中直接子元素的时候匹配。继承关系上更远的后代则不会匹配。article > p
邻接兄弟选择器：用（+）来选中恰好处于另一个在继承关系上同级的元素旁边的物件。选中所有紧随<p>元素之后的<img>元素：p + img
通用兄弟选择器：选中一个元素的兄弟元素，即使它们不直接相邻。要选中所有的<p>元素后任何地方的<img>元素 p ~ img
*/
ul > li[class="a"] {
    background-color: red;
}
</style>
